\input{4-transactions-security/sections/tables/dataset}
\section{Methodology}
\label{sec:4:methodology}
In this section, we describe the methodology used to measure the transactional throughput of the selected blockchains.

\subsection{Definitions}
We first introduce important definitions used in the rest of this chapter.

\point{Throughput-related definitions}
When quantified, a throughput value is expressed in TPS (transactions per second).
\begin{description}
\item[Alleged Capacity] The theoretical capacity that a blockchain claims to be able to achieve
\item[Average Throughput] Average throughput recorded on the network throughout the observation period
\item[Maximum Throughput] Maximum throughput recorded on the network during the observation period
%\item[Value Transfers] A transfer of an asset holding a non-zero value.
\end{description}

\point{Blockchain-related definitions}
We unify the terms that we use across the systems analysed in this work.
We sometimes diverge from the definition provided by a particular blockchain for terminological consistency.

\begin{description}
\item[Block] Entity recorded on a blockchain and included as part of the blockchain to \emph{advance} its state. Blocks are named as such on EOSIO and Tezos, while the equivalent on XRPL is termed a ``ledger''.
\item[Transaction] Entity included at the top-level of a block and typically representing an atomic state transition. These are named as such on EOSIO and XRPL but are called ``operations'' in Tezos.
\item[Action] Entity included as part of the transaction and describing what the transaction should do. EOSIO and Tezos can have multiple actions per transaction. A single transaction containing multiple actions is only counted towards throughput once.
Actions are called as such in EOSIO and are the ``contents'' of an ``operation'' on Tezos. XRPL does not feature this concept and each XRPL transaction can be thought of as a single action.
\end{description}


\subsection{Measurement Framework}
We implement an extensible and reusable measurement framework to facilitate future transaction analysis-related research.
Our framework currently supports the three blockchains analysed in this work, Tezos, EOSIO and XRPL but can easily be extended to support other blockchains.
The core of the software is implemented in Go and is designed to work well on a single machine with many cores.
The framework frontend is provided as a cross-platform static binary command line tool.

While the framework is responsible for the heavy lifting and processing of gigabytes of data, we also provide a companion tool implemented in Python to generate plots and tables from the data generated by the framework.
\point{Data fetching}
The framework currently allows fetching data either using RPC over HTTP or websockets.
Tezos and EOSIO both use the HTTP adapter to retrieve data while XRPL uses the websocket interface.
The data is retrieved from publicly available archive nodes but the framework can be configured to use other nodes if necessary.
The retrieved data is stored in a gzipped JSON Lines format where each line corresponds to a block. Blocks are stored in chunks of $n$ blocks per file --- where $n$ can be configured --- making parallel processing straightforward. It took less than two days to fetch all the data presented in~\autoref{tab:data-summary}.

\begin{figure}[h!]
\begin{lstlisting}[language=json]
{
  "Pattern": "/data/eos_blocks-*.jsonl.gz",
  "StartBlock": 82152667,
  "EndBlock": 118286375,
  "Processors": [{
      "Name": "TransactionsCount",
      "Type": "count-transactions"
    }, {
      "Name": "GroupedActionsOverTime",
      "Type": "group-actions-over-time",
      "Params": {
        "By": "receiver",
        "Duration": "6h"
      }
    }, {
      "Name": "ActionsByName",
      "Type": "group-actions",
      "Params": {
        "By": "name"
      }
    }
}
\end{lstlisting}
  \caption{Configuration file for our measurement framework}
  \label{lis:framework-config}
\end{figure}

\point{Data processing}
The framework provides several processors which can mainly be used to aggregate the data either over time or over certain properties such as the sender of a transaction.
The framework is configured using a single JSON file, containing the configuration for the data to be processed as well as the specification of what type of statistics should be collected from the dataset. We show a sample configuration file in~\autoref{lis:framework-config}.
This configuration computes three statistics from block~82,152,667 to block~118,286,375, using the data contained in all the files matching~\lstinline{/data/eos_blocks-*.jsonl.gz}.
The framework will compute the total number of transactions, the number of actions grouped using their receiver over a period of 6 hours, and finally the total number of actions grouped by their name.
All the statistics described above can be used for all the blockchains but the framework also supports blockchain-specific statistics where needed.
New statistics can easily be added to the framework by implementing a common interface.

Our framework was able to analyze the data and output all the statistics required for this chapter in less than 4 hours using a powerful 48-core machine.

\begin{figure}[ht]
\begin{lstlisting}[language=go]
type Blockchain interface {
    FetchData(filepath string,
              start, end uint64) error
    ParseBlock(rawLine []byte) (Block, error)
    EmptyBlock() Block
}

type Block interface {
    Number() uint64
    TransactionsCount() int
    Time() time.Time
    ListActions() []Action
}

type Action interface {
    Sender() string
    Receiver() string
    Name() string
}
\end{lstlisting}
  \caption{Main interfaces of our measurement framework}
  \label{lis:framework-interfaces}
\end{figure}

\point{Extending to other blockchains}
The framework has been made as generic as possible to allow the integration of other blockchains when performing similar kinds of analysis.
In particular, the framework contains three main interfaces shown in~\autoref{lis:framework-interfaces}.
The \lstinline{FetchData} method can be implemented by reusing the HTTP or websocket adapters provided by the framework while the \lstinline{Block} and \lstinline{Action} interfaces typically involve defining the schema of the block or action of the blockchain implemented.
In our implementation, adding a blockchain takes on average 105 new lines of Go code not including tests.


\subsection{Data Collection}
We collect historical data on the three blockchains from \startdate to \finishdate.
We provide an overview of the characteristics of the data in~\autoref{tab:data-summary}.
We note that the number of transactions is not the same as in~\autoref{tab:transaction-types-distribution} as here we count only a transaction once, while in the previous table, we counted all the actions included in a single transaction.

For all three of the blockchains, we first pinpoint the blocks which correspond to the start and end of our measurement period and use our framework to collect all the blocks included in this range.
Each time, we use publicly available nodes or data providers to retrieve the necessary data.

\point{EOSIO}
EOSIO nodes provide an RPC API~\cite{EOS.IO2020} which allows clients to retrieve the content of a single block, through the~\texttt{get\_block} endpoint~\cite{EOSDocs2020}.
EOSIO also has a list of block producers who usually provide a publicly accessible RPC endpoint. Out of 32 officially advertised endpoints, we shortlist 6 that have a generous rate limit with stable latency and throughput.

We collect data from block~\empirical{\numprint{\EOSStartBlock}} to block~\empirical{\numprint{\EOSEndBlock}}, or a total of~\empirical{\blockscount{\EOSStartBlock}{\EOSEndBlock}} blocks containing~\empirical{631,445,236} transactions, representing more than~\empirical{260}GB of data.

\point{Tezos}
Similar to EOSIO, Tezos full nodes provide an RPC API and some bakers make it publicly available. We measure the latency and throughput of several nodes and select the one for which we obtained the best results~\cite{tezos-ukraine}.
We obtain~\empirical{\blockscount{\TezosStartBlock}{\TezosEndBlock}} blocks containing~\empirical{7,890,133} transactions, for a total size of approximately \empirical{1.4} GB of data.

\point{XRPL}
XRPL has both an RPC API and a websocket API with similar features. Although there are no official public endpoints for XRPL, a high-availability websocket endpoint is provided by the XRP community~\cite{Wind2020}. We use the \texttt{ledger} method of the websocket API to retrieve the data in the same way we did with EOSIO and Tezos.

In addition, we use the API provided by the ledger explorer XRP Scan~\cite{xrpscan} to retrieve account information including username and parent account.\footnote{A parent account sends initial funds to activate a new account.} 
Since large XRP users such as exchanges often have multiple accounts, this account information can be used to identify and cluster accounts.

In total, we analyze \blockscount{\XRPStartBlock}{\XRPEndBlock} blocks covering seven months of data and containing a total of more than~\empirical{150} million transactions. The total size of the compressed data is about~\empirical{130} GB.



% - network analysis

% - forensics

% - measuring traffic, 

% - behaviour pattern of senders, receivers, nodes

% - clustering senders / receivers -- relationship analysis

% - nature of transactions

% - transferability of our method-- people can use it to analyze other blockchains 

% - we create a measurement framework: define "claimed", "actual, average", "maximum", "useful" throughput and analyze gaps \autoref{tab:claims-throughput}
