\section{Towards a Better Approach}
\label{sec:3:design}

Gas metering and pricing is a difficult but fundamental problem in Ethereum and other blockchains which use a similar approach to price contract execution. Mispricing of gas instructions has been a concern for a long time and improvements have been included in several hard forks~\cite{erc150,eip2200}. However, there remain issues in the current Ethereum pricing model, allowing attacks such as the one we presented in the previous sections. In this section, we will discuss short-term fixes which can be used to prevent DoS such as the one presented in this chapter, and then briefly present longer-term potential solutions which are still being actively researched. 

The main attack vector presented in this chapter comes from the low speed of searching for an account which is not currently cached. One of the main issues is that the state of Ethereum gets larger with time. This means that operations accessing the state get more expensive with time in terms of resource usage.

\point{Short-term fixes}
Short-term fixes for slow IO-related issues can be categorised in the two following classes: increase in the gas cost of IO instructions, as seen in EIP-150~\cite{erc150} and EIP-2200~\cite{eip2200}, and improvements in the speed of Ethereum clients.

Increasing the cost of IO instructions improves the fairness of the gas costs yet is often not sufficient to protect against DoS attacks, albeit it does increase their cost. The attack we present in this chapter uses mainly instructions whose prices have increased in EIP-150 or EIP-2200 but remain relatively cheap to execute.

Improvements involve adding more layers of caches to reduce the number of IO accesses, which are typically the bottleneck. However, this requires keeping more data in memory and therefore creates a trade-off between memory consumption and execution speed. Regarding account lookup, two cases must be considered: when the looked-up account exists and when it does not. Naively caching all the accounts could allow an attacker to easily evict existing accounts from the cache and is therefore dangerous. To check whether a particular account exists, a Bloom filter can be utilised as a first test. This eliminates the need for most of the IO accesses in case the queried address does not exist while keeping a relatively low memory footprint~\cite{mitzenmacher2002compressed}. The next case which needs to be handled is the fast lookup of existing accounts. The current attempt to do this keeps an on-disk dynamic snapshot of the accounts state~\cite{dynamic-trie-snapshot-pr}, which allows performing an on-disk look-up of an account in~$\mathcal{O}(1)$, at the cost of increasing the storage usage of the node. This indeed solves the bottleneck of accessing account data but is very specific to this particular issue.

\point{Long-term fixes}
Long-term fixes are likely to only arrive in Ethereum~2.0, as most of them will require major and breaking changes. There have been several solutions discussed by the community and other researchers, which can mostly be categorised as either a)~changing the gas pricing mechanism or b)~changing the way clients store data.

Current proposals to change the gas mechanism involve making the pricing more dynamic than it is currently. Chen et al.~\cite{Chen2017Metering} propose a mechanism where contracts using a single instruction in excess would be penalised. The threshold is set using historical data in order to penalise only contracts which diverge too much from regular usage. Although the approach has some advantages over the current pricing mechanism, it is unclear how well it would be able to prevent attacks taking this mechanism into account.

A promising and actively researched approach is the use of stateless clients and stateless validation. The key idea is that instead of forcing clients to store the whole state, the entity emitting transactions must send the transaction, the data needed by the transactions, and proof that this data is correct. The proof can be fairly trivially constructed as a Merkle proof, as the block headers hold a hash of the root of the state and the state can be represented as a Merkle tree. This allows such clients to verify all transactions without accessing IO resources at all, making execution and storage much cheaper, at the cost of an increased complexity when creating transactions and higher bandwidth usage.

Another active area of research which should help make things better in this direction is sharding~\cite{al2017chainspace}. Although sharding does not address the fundamental issue of gas pricing in the presence of IO operations, it does help to keep the state of the nodes smaller, as different shards will be responsible for storing the state of different parts of the network.
