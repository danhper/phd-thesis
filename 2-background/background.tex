\chapter{Background Theory}
\label{ch:background}

In this chapter, we will provide background about blockchains, smart contracts, and their applications that will be useful for understanding the rest of the thesis.
More specific background information, such as some more details about the Ethereum platform, will be provided in the relevant chapters.

\section{Blockchain fundamentals}
In its essence, a blockchain is an append-only, decentralized database that is replicated across multiple computer nodes. 
Most blockchain systems record activities in the form of ``transactions''. 
A transaction typically contains information about its sender, its receiver, as well as the action taken, such as the transfer of an asset. 
Newly created transactions are broadcast across the network where they get validated by the participants. 
Valid transactions are grouped into data structures called \textit{blocks}, which are appended to the blockchain by referencing the most recent block.
Blocks are immutable, and state changes in the blockchain require new blocks to be produced.

Network latency and asynchrony inherent in the distributed nature of blockchains lead to a number of challenges. 
In particular, a blockchain must be able to reach consensus about the current state when the majority of participating nodes behave honestly. 
In order to resolve the disagreement, a consensus protocol prescribing a set of rules is applied as part of the validation process. 

To ensure consistency, there needs to be:

\begin{enumerate}\itemsep=-1pt
\item a set of rules to validate transactions \label{req1};
\item a set of rules to validate blocks \label{req2};
\item a mechanism to determine which chain of blocks represents the current state \label{req3}
\end{enumerate}

%
In the following subsections, we will provide definitions and explanations about transactions, blocks and consensus mechanisms, and then describe how the above requirements are fulfilled in most existing blockchain systems.

% Requirement (\ref{req1}) is usually straightforward to implement, each participant simply verifies that the set of rules holds for each transaction.
% Most blockchains also have a simple solution for Requirement (\ref{req3}): they treat the longest existing chain of blocks as the valid one.
% The biggest challenge, and diversity of solutions arise when it comes to solving Requirement (\ref{req2}).
% Bitcoin provides the first practical solution to this problem, namely, Proof-of-Work~(PoW).
% Participating nodes who propose new blocks compete to solve a computationally expensive puzzle, and blocks are deemed valid if Requirement (i) they include a solution to this puzzle and (ii) all transactions they contain are valid.

\subsection{Transactions and blocks}
\point{Transactions} The smallest unit of work in most blockchain systems, including Bitcoin and Ethereum, is a transaction.
The exact content of a transaction varies between different systems. It typically contains information about the sender, the receiver, the amount of the asset being transferred, and information on the fees to be paid for the transaction to be processed.
In the case of Ethereum, transactions can also contain arbitrary data, which can be used to invoke smart contracts, which we will cover in more depth further in this chapter.
As part of the set of rules to fulfil Requirement \ref{req1} above, transactions are signed by the sender, and the signature is used to verify that the transaction is valid.
The systems also verify that the sender has enough funds to cover the transaction, including its associated fees, and that the transaction is not a duplicate of a previously processed transaction.
Finally, in the case of a smart contract interaction, the execution of the smart contract must also be successful.

\point{Blocks}
A block is a collection of transactions that are grouped together and appended to the blockchain.
Blocks typically contain some extra metadata, such as a hash of the previous block, effectively linking them together, a timestamp, and information about the transactions included in the block.
Each block is usually limited to a maximum number of transactions, and a block is considered valid if all transactions it contains are valid.
However, this is not the only requirement for a block to be deemed valid since this requirement alone would be prone to double-spending.
To fulfil Requirement \ref{req2} above, some consensus algorithm needs to be used.
We will discuss the most common consensus algorithms in the next subsection.

\subsection{Consensus}
\point{Proof-of-Work}
The Proof-of-Work (PoW) consensus, introduced by Bitcoin requires the participant to solve a computationally expensive puzzle to create a new block. Although PoW can maintain consistency well, it is by nature very time- and energy-consuming, which limits its throughput.
To preserve security while maintaining a sufficient degree of decentralization, scalability is often sacrificed~\cite{Xie2019}.
Indeed, the rate of block creation for both Bitcoin is relatively slow---on average 10 minutes per block, respectively---and the only way to increase the throughput is to increase the size of a single block, allowing for more transactions per block.

\point{Proof-of-Stake}

Ethereum has recently transitioned to a new consensus mechanism called Proof-of-Stake (PoS), which solves the same issue as PoW but does not require a large amount of computational power.

\point{Deciding on the valid chain}
These consensus mechanisms alone are not enough to fulfil Requirement \ref{req3}.
In both PoW and PoS, there could be two competing versions of the blockchain containing a different chain of blocks.
For PoW, this could for example happen if two miners have found a solution to the puzzle at the same time.
The most common solution to this problem is to treat the longest chain of blocks as the valid one.
In the case of PoW, the longest chain is not exactly the one that contains the most blocks but the one that contains the most work, i.e., the one that requires the most computational effort to produce.
In the case of PoS, the issue is more complex since it does not require any computational effort to produce a block.
This means that in theory, someone could produce a large number of blocks to create the longest chain.
To prevent this, multiple mechanisms exist but the one used by Ethereum is to force blocks to be produced within a fixed interval of time and to use some blocks as checkpoints that cannot be reverted.


\subsection{Incentives and fees}

\section{Smart contracts}
The Ethereum~\cite{buterin2014} platform allows its users to run ``smart contracts'' on its distributed infrastructure.
Ethereum \emph{smart contracts} are programs which define a set of rules for the governing of associated funds, typically written in a Turing-complete programming language called Solidity~\cite{Dannen:2017:IES:3103305}.
Solidity is similar to JavaScript, yet some notable differences are that it is strongly typed and has built-in constructs to interact with the Ethereum platform.
Programs written in Solidity are compiled into low-level untyped bytecode to be executed on the Ethereum platform by the Ethereum Virtual Machine (EVM)~\cite{wood2014ethereum}.
It is important to note that it is also possible to write EVM contracts without using Solidity.

To execute a smart contract, a sender has to send a transaction to the contract and pay a fee which is derived from the contract's computational cost, measured in units of~\emph{gas}. Each executed instruction consumes an agreed-upon amount of gas~\cite{wood2014ethereum}. Consumed gas is credited to the miner of the block containing the transaction, while any unused gas is refunded to the sender. In order to avoid system failure stemming from never-terminating programs, transactions specify a gas limit for contract execution. An out-of-gas exception is thrown once this limit has been reached.

Smart contracts themselves have the capability to \emph{call} another account present on the Ethereum blockchain. This functionality is overloaded, as it is used both to call a function in another contract and to send Ether (ETH), the underlying currency in Ethereum, to an account. A particularity of how this works in Ethereum is that calls from within a contract, also called \emph{internal transactions}, do not create new transactions and are therefore not directly recorded on-chain. This means that looking at transactions without executing them does not provide enough information to follow the flow of Ether.


\section{Applications}

\point{DAOs} 
A Decentralized Autonomous Organization (DAO) operates based on computer programs called smart contracts, rather than being subject to the control of any central authority or group of individuals. Decisions within a DAO are reached through a consensus mechanism that permits stakeholders to suggest, deliberate, and vote on various proposals. The blockchain executes the rules and decision-making process in a transparent manner, resulting in a trustless system.
DAOs can serve a variety of functions, such as managing decentralized funds, investing in projects, creating decentralized social networks, or facilitating community governance. The use cases of DAOs are constantly changing as technology advances, and they are viewed as a promising tool for enabling decentralized and autonomous decision-making.
\point{DeFi}
Decentralized Finance (DeFi) is a peer-to-peer financial system powered by a blockchain, usually Ethereum, that is designed to operate without the need for traditional financial intermediaries such as banks, brokerages, or exchanges.
In a DeFi system, financial transactions and services are facilitated by smart contracts that automatically execute transactions and enforce the terms of agreements. Examples of DeFi applications include decentralized exchanges (DEXs), where users can trade cryptocurrencies without the need for a centralized exchange, lending platforms that enable borrowers to access loans without going through a traditional bank, and stablecoins that are designed to maintain a stable value.
\point{NFTs}

\section{Motivating examples of Attacks on Blockchain Systems}

\point{Shanghai attack}
\point{Polygon DDoS}
\point{DAO hack}
\point{Cream Finance exploit}
