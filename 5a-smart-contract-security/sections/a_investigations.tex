\subsection{Investigations}
\label{sec:5a:investigations}
In this section, we will give a more in-depth security analysis of the top value contracts we presented in Section~\ref{sec:discussion}. In particular, we will focus on the vulnerabilities detected by the different tools and show how it could, or not, affect the contract.

\subsection*{\addr{0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae}}
  This contract has been flagged as being vulnerable to re-entrancy by Oyente. For a contract to be victim of a re-entrancy attack, it must \lstinline{CALL} another contract, sending it enough gas to be able to perform the re-entrant call. In Solidity terms, this is means that the contract has to invoke \lstinline{address.call} and not explicitly set the gas limit. By looking at the source code~\cite{ether-foundation-contract-code}, we find 2 such instances: one at line 352 in the \lstinline{execute} function and another at line 369 in the \lstinline{confirm function}. The \lstinline{execute} is protected by the \lstinline{onlyowner} modifier, which requires the caller to be an owner of the wallet. This means that for a re-entrant call to work, the malicious contract would need to be an owner of the wallet in order to work. The \lstinline{confirm} function is protected by the \lstinline{onlymanyowners} modifier, which requires at least n owners to agree on confirming a particular transaction before it is executed, where n is agreed upon at contract creation time. Furthermore, \lstinline{confirm} will only invoke \lstinline{address.call} on a transaction previously created in the \lstinline{execute} function.

\subsection*{\addr{0x7da82c7ab4771ff031b66538d2fb9b0b047f6cf9}}
This is the contract for multi-signature wallet of the Golem project~\cite{golem-project} and uses a well-known multi-signature implementation. We use the source code available on Etherscan to perform the audit.
This contract is marked with two vulnerabilities, locked Ether by MadMax and integer overflow by Zeus.

We first focus on the locked Ether which is due to an unbounded mass operation~\cite{Grech2018}. An unbounded mass operation is flagged when a loop is bounded by a variable which value could increase, for example the length of an array. This is because if the number of iteration becomes too large the contract would run out of gas every time, which could indeed result in locked funds. Therefore, we check all the loops in the contract. There are 8 loops in the code, at lines 43, 109, 184, 215, 234, 246, 257 and 265. All the loops except the ones at lines 257 and 265 are bound by the total number of owners. As owner can only be added if enough existing owners agree, running out-of-gas when looping on the number of owners cannot happen unless the owners agree. The loops at lines 257 and 265 are in a function called \lstinline{filterTransactions} and are bounded by the number of transactions. The function \lstinline{filterTransactions} is only used by two external getters, \lstinline{getPendingTransactions} and \lstinline{getExecutedTransactions} and could therefore not result the Ether getting lock. However, as the number of transactions is ever increasing, if the owner submit enough transactions, the \lstinline{filterTransactions} function could indeed need to loop over too many transactions and end up running out-of-gas on every execution. We estimate the amount of gas used in the loop to be around 50 gas, which means that if the number of transactions reaches 100,000, it would required more than 5,000,000 gas to list the transactions, which would probably make all calls run out of gas. The contract has only received a total of 281 transactions in more than 3 years so it is very unlikely that the number of transactions increase this much. Nevertheless, this is indeed an issue which should be fixed, most likely by limiting the maximum numbers of transactions that can be retrieved by \lstinline{getPendingTransactions} and \lstinline{getExecutedTransactions}.

Next, we look for possible integer overflows. All loops discussed above use an \lstinline{uint} as a loop index. In Solidity, \lstinline{uint} is a \lstinline{uint256} which makes it impossible to overflow here, given than neither the number of owners or transactions could ever reach such a number. The only other arithmetic operation performed is \lstinline{owners.length - 1} in the function \lstinline{removeOwner} at line 103. This function checks that the owner exists, which means that \lstinline{owners.length} will always be at least 1 and \lstinline{owners.length} can therefore never underflow.

\subsection*{\addr{0x851b7f3ab81bd8df354f0d7640efcd7288553419}}
This contract is also a multi-sig wallet, this time owned by Gnosis Ltd.\footnote{\url{https://gnosis.io/}} We use the source code available on Etherscan to perform the audit. The contract looks very similar of the one used by \addr{0x7da82c7ab4771ff031b66538d2fb9b0b047f6cf9} and has also been marked by MadMax as being vulnerable to locked Ether because of unbounded mass operations. Again, we look at all the loops in the contract and find that as the previous contract, it loops exclusively on owners and transactions. As in the previous contract, we assume looping on the owners is safe and look at the loops over the transactions. This contract has two functions looping over transactions, \lstinline{getTransactionCount} at line 303 and \lstinline{getTransactionIds} at line 351. Both functions are getters which are never called from within the contract. Therefore, no Ether could ever be locked because of this. Unlike the previous contract, \lstinline{getTransactionIds} allows to set the range of transactions to return, therefore making the function safe to unbounded mass operations. However, \lstinline{getTransactionCount} does loop over all the transactions, and as before, could therefore become unusable at some point, although it is highly unlikely.

\subsection*{\addr{0xcafe1a77e84698c83ca8931f54a755176ef75f2c}}
This contract is again a multi-sig wallet, this time owned by the Aragon project\footnote{\url{https://aragon.org/}}. We also use the contract published on Etherscan for the audit. It appears that the source code for this contract is exactly the same as the one of \addr{0x851b7f3ab81bd8df354f0d7640efcd7288553419} except that it is missing a contract called \lstinline{MultiSigWalletWithDailyLimit}. This contract was also flagged as being at risk of unbounded mass operations by MadMax, the conclusions are therefore exactly the same as for the previous contract.

\subsection*{\addr{0xbf4ed7b27f1d666546e30d74d50d173d20bca754}}
This contract is the only one which is very different from the previous ones. It is the \lstinline{WithdrawDAO} contract, which has been created for users to get their funds back after TheDAO incident~\cite{Securities2017}. We use the source code from Etherscan to audit the contract.
This contract has been flagged with several vulnerabilities: Securify flagged it with transaction order dependency and unhandled exception, while Zeus flagged it with locked ether and integer overflow.
The contract has two very short functions: \lstinline{withdraw} which allows users to convert their TheDAO tokens back to Ether, and the \lstinline{trusteeWithdraw} which allows to send funds which cannot be withdrawn by regular users to a trusted address.
We first look at the transaction order dependency. As any user will only ever be able to receive the amount of tokens he possesses, the order of the transaction should not be an issue in this contract. We then look at unhandled exceptions. There is indeed a call to \lstinline{send} in the \lstinline{trusteeWithdraw} which is not checked. Although it is not particularly an issue here, as this does not modify any other state, an error should probably be thrown if the call fails. We then look at locked ether. The contract is flagged with locked ether because of what Zeus classifies as ``failed send''. This issue was flagged because if the call to \lstinline{mainDAO.transferFrom} always raised, then the call to \lstinline{msg.sender.send} would never be reached, indeed preventing from reclaiming funds. However, in this context, \lstinline{mainDAO} is a trusted contract and it is therefore safe to assume that \lstinline{mainDAO.transferFrom} will not always fail. Finally, we look at the integer overflow issue. The only place where an overflow could occur is in \lstinline{trusteeWithdraw} at line 23. This could indeed overflow without some assumptions on the different values. For this particular contract, the following assumptions are made.

\lstset{
  basicstyle=\ttfamily,
  mathescape
}
\begin{align*}
  &\text{\lstinline{this.balance}} \mbox{\footnotesize $+$} \text{\lstinline{mainDAO.balanceOf(this)}} \mbox{\footnotesize $\geq$} \text{\lstinline{mainDAO.totalSupply()}}\\
  &\text{\lstinline{mainDAO.totalSupply()}} \mbox{\footnotesize $>$} \text{\lstinline{mainDAO.balanceOf(this)}}
\end{align*}

As long as these assumptions hold, which was the case when the contract was deployed, this expression will never overflow. Indeed, if we note $t$ the time before the first call to \lstinline{trusteeWithdraw} and $t + 1$ the time after the first call, we will have
\begin{lstlisting}
this.balance$_{t+1}$ = this.balance$_t$ - (
  this.balance$_t$ + mainDAO.balanceOf(this)
                - mainDAO.totalSupply())
 = -mainDAO.balanceOf(this)+mainDAO.totalSupply()
\end{lstlisting}

% \begin{align*}
%   \text{\lstinline{this.balance}}_{t+1} &\mbox{\footnotesize $=$} \text{\lstinline{this.balance}}_t \mbox{\footnotesize $-$}\\
%   (\text{\lstinline{this.balance}}_t &\mbox{\footnotesize $+$}\text{\lstinline{mainDAO.balanceOf(this)}} \mbox{\footnotesize $-$} \text{\lstinline{mainDAO.totalSupply()}})\\
%   &\mbox{\footnotesize $=$} \mbox{\footnotesize $-$}\text{\lstinline{mainDAO.balanceOf(this)}} \mbox{\footnotesize $+$}\text{\lstinline{mainDAO.totalSupply()}}
% \end{align*}

which means that every subsequent call will compute the following.

\begin{lstlisting}
this.balance$_{t+1}$ + mainDAO.balanceOf(this) -
                       mainDAO.totalSupply()
 = -mainDAO.balanceOf(this)+mainDAO.totalSupply()+
   mainDAO.balanceOf(this) - mainDAO.totalSupply()
 = 0
\end{lstlisting}

% \begin{align*}
%   &\text{\footnotesize\lstinline{this.balance}}_{t+1} + \text{\footnotesize\lstinline{mainDAO.balanceOf(this)}} - \text{\footnotesize\lstinline{mainDAO.totalSupply()}}\\
%   &= -\text{\footnotesize\lstinline{mainDAO.balanceOf(this)}} +\text{\footnotesize\lstinline{mainDAO.totalSupply()}} + \\
%   &\quad\text{\footnotesize\lstinline{mainDAO.balanceOf(this)}} - \text{\footnotesize\lstinline{mainDAO.totalSupply()}}\\
%   &= 0
% \end{align*}

This will always result in sending $0$ and will therefore not cause any overflow. If some money is newly received by the contract, the amount received will be transferred the next time \lstinline{trusteeWithdraw} is called.
